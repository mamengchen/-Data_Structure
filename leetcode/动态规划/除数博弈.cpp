//爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。
//最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作：
//选出任一 x，满足 0 < x < N 且 N % x == 0 。
//	用 N - x 替换黑板上的数字 N 。
//	如果玩家无法执行这些操作，就会输掉游戏。
//	只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 false。假设两个玩家都以最佳状态参与游戏。
//
//
//	示例 1：
//	输入：2
//	输出：true
//	解释：爱丽丝选择 1，鲍勃无法进行操作。
//	示例 2：
//	输入：3
//	输出：false
//	解释：爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。

class Solution {
public:
	bool divisorGame(int N) {
		if (N < 2)
			return false;
		vector<bool> my_vec(N + 1, false);
		for (int i = 2; i <= N; i++)
		{
			for (int j = 1; j < i; j++)
			{
				if (!my_vec[i - j] && i%j == 0)
				{
					my_vec[i] = true;
					break;
				}
			}
		}
		return my_vec[N];
	}
};

第二种方法：
解释：这个题如果你给的是奇数则第一个人一直处理的是奇数，
如果你给的是偶数则一直处理偶数，如果想赢则需要一直处理偶数。
原理：你一个奇数必须是两个奇数相乘才可以得到的，所有说，你可以整除的一定是一个奇数，
奇数减奇数等于偶数，而一个偶数既可以用一个奇数整除又可以使用一个偶数整除，
如果那个人要抱着赢得心态就是一直选奇数，这样下一个又变成奇数了。
class Solution {
public:
	bool divisorGame(int N) {
		return N % 2 == 0 ? true : false;
	}
};